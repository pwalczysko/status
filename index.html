<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <title>OME Project Dashboard</title>
  <link href="static/style.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/simple-datatables@latest/dist/style.css">
  <link rel="icon" href="favicon.ico">
  <script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/simple-datatables@latest"></script>
</head>

<body>
  <div id="wrapper">
    <h1>OME Project Dashboard</h1>
    <p class="subtitle">OME-owned and OME-related projects (<a href="https://github.com/ome/status"
        target="_blank">source</a>). For workflows, see the <a
        href="https://github.com/ome/ome-resources-monitor/blob/main/logs/latest.md"
        target="_blank">ome-resource-monitor</a>.
    </p>
    <p id="generated-at" class="meta-cell"></p>
    <div id="error" class="error-note" style="display:none;"></div>
    <div id="sections">
      <div class="section-card">
        <p class="meta-cell">Loading dashboard...</p>
      </div>
    </div>
  </div>
  <noscript>
    <div class="section-card error-note">Enable JavaScript to view the dashboard.</div>
  </noscript>
  <script>
    (function () {
      const sectionsEl = document.getElementById('sections');
      const generatedAtEl = document.getElementById('generated-at');
      const errorEl = document.getElementById('error');

      const headers = [
        { text: 'Owner' },
        { text: 'Name' },
        { text: 'â­', title: 'Stargazers' },
        { text: 'ðŸ“¬', title: 'Open issues + PRs' },
        { text: 'ðŸš€', title: 'Created' },
        { text: 'ðŸ“', title: 'Last commit' },
        { text: 'ðŸ“¦', title: 'Last release' },
        { text: 'ðŸ·ï¸', title: 'Topics' },
      ];

      function emptyMarker() {
        const span = document.createElement('span');
        span.className = 'empty';
        span.textContent = '--';
        return span;
      }

      function createStatusIcon(status) {
        if (!status) return null;
        const normalized = String(status).toUpperCase();
        const map = {
          SUCCESS: { text: 'âœ“', className: 'status-success' },
          FAILURE: { text: 'âœ—', className: 'status-failure' },
          ERROR: { text: 'âœ—', className: 'status-failure' },
          PENDING: { text: 'â€¢', className: 'status-pending' },
        };
        const match = map[normalized];
        if (!match) return null;
        const span = document.createElement('span');
        span.className = 'status-icon ' + match.className;
        span.textContent = match.text;
        span.title = 'Checks: ' + normalized.toLowerCase();
        return span;
      }

      function normalizeSortValue(rawValue) {
        if (rawValue === undefined || rawValue === null || rawValue === '') {
          return Number.NEGATIVE_INFINITY;
        }
        const numericValue = Number(rawValue);
        return Number.isFinite(numericValue) ? numericValue : Number.NEGATIVE_INFINITY;
      }

      function setError(message) {
        errorEl.textContent = message;
        errorEl.style.display = 'block';
      }

      function clearError() {
        errorEl.textContent = '';
        errorEl.style.display = 'none';
      }

      function formatDateMonth(value) {
        if (!value) return '';
        const date = new Date(value);
        if (Number.isNaN(date.getTime())) return value;
        return date.toISOString().slice(0, 7);
      }

      function formatYear(value) {
        if (!value) return '';
        const date = new Date(value);
        if (Number.isNaN(date.getTime())) return value;
        return date.toISOString().slice(0, 4);
      }

      function formatDateDay(value) {
        if (!value) return '';
        const date = new Date(value);
        if (Number.isNaN(date.getTime())) return value;
        return date.toISOString().slice(0, 10);
      }

      async function fetchYaml(path, { optional = false } = {}) {
        const response = await fetch(path);
        if (!response.ok) {
          if (optional) return null;
          throw new Error('Request failed with status ' + response.status);
        }
        const text = await response.text();
        return jsyaml.load(text);
      }

      function buildOwnerLogoUrl(owner) {
        if (!owner) return '';
        return 'https://avatars.githubusercontent.com/' + encodeURIComponent(owner);
      }

      function buildActionsUrl(repo) {
        if (!repo) return '';
        return 'https://github.com/' + repo + '/actions';
      }

      function createDisabledScheduleIcon(disabledWorkflows, repo) {
        const workflows = Array.isArray(disabledWorkflows) ? disabledWorkflows : [];
        if (workflows.length === 0) return null;
        const label = workflows.length ? workflows.join(', ') : 'workflows';
        const actionsUrl = buildActionsUrl(repo);
        const link = document.createElement('a');
        link.className = 'status-icon status-warning status-icon-link';
        link.textContent = '!';
        link.href = actionsUrl || '#';
        link.title = 'Scheduled workflows disabled due to inactivity: ' + label;
        link.setAttribute('aria-label', link.title);
        return link;
      }

      function createTextCell(value, className, sortValue) {
        const td = document.createElement('td');
        if (className) td.className = className;
        if (sortValue !== undefined) {
          td.dataset.order = normalizeSortValue(sortValue);
        }
        if (value === undefined || value === null || value === '') {
          td.appendChild(emptyMarker());
        } else {
          td.textContent = value;
        }
        return td;
      }

      function formatNumber(value) {
        const num = Number(value);
        return Number.isFinite(num) ? num.toLocaleString('en-US') : value;
      }

      function createNameCell(pkg) {
        const td = document.createElement('td');
        td.style.textAlign = 'left';
        const link = document.createElement('a');
        const repo = pkg.repo || pkg.name || 'unknown';
        link.href = 'https://github.com/' + repo;
        link.textContent = pkg.name || repo;
        const desc = pkg.repo_info && pkg.repo_info.description;
        if (desc) {
          link.title = desc;
        }
        td.appendChild(link);
        return td;
      }

      function createOwnerCell(pkg) {
        const td = document.createElement('td');
        td.className = 'owner-cell';
        const owner = pkg.user;
        if (!owner) {
          td.appendChild(emptyMarker());
          return td;
        }
        td.dataset.order = (owner && owner.toLowerCase) ? owner.toLowerCase() : owner;
        const link = document.createElement('a');
        link.href = 'https://github.com/' + owner;
        link.className = 'owner-link';
        link.title = owner;
        link.setAttribute('aria-label', owner);
        const logoUrl = buildOwnerLogoUrl(owner);
        if (logoUrl) {
          const img = document.createElement('img');
          img.alt = owner + ' logo';
          img.src = logoUrl;
          img.loading = 'lazy';
          img.className = 'owner-logo';
          img.onerror = () => {
            img.remove();
            link.textContent = owner;
          };
          link.appendChild(img);
        }
        td.appendChild(link);
        return td;
      }

      function createLastCommitCell(commit, disabledWorkflows, repo) {
        const td = document.createElement('td');
        td.className = 'commit-cell';
        const hasCommitContent = commit && (commit.date || commit.url || commit.author);
        const hasDisabled = Array.isArray(disabledWorkflows) && disabledWorkflows.length > 0;
        const sortDate = commit && commit.date ? Date.parse(commit.date) : null;
        td.dataset.order = normalizeSortValue(sortDate);
        if (!hasCommitContent && !hasDisabled) {
          td.appendChild(emptyMarker());
          return td;
        }
        const dateClass = classifyEntryAge(commit && commit.date);
        const dateDiv = document.createElement('div');
        dateDiv.className = 'commit-date';
        if (dateClass) {
          dateDiv.classList.add(dateClass);
        }
        const statusIcon = commit ? createStatusIcon(commit.status) : null;
        const disabledIcon = createDisabledScheduleIcon(disabledWorkflows, repo);
        if (commit && commit.url) {
          const link = document.createElement('a');
          link.href = commit.url;
          link.textContent = formatDateMonth(commit.date) || 'commit';
          const tooltipBits = [];
          if (commit.date) tooltipBits.push('Date: ' + formatDateDay(commit.date));
          if (commit.author) tooltipBits.push('Author: ' + commit.author);
          link.title = tooltipBits.join(' â€¢ ');
          dateDiv.appendChild(link);
        } else if (commit && commit.date) {
          dateDiv.textContent = formatDateMonth(commit.date) || 'commit';
        } else {
          dateDiv.textContent = '';
        }
        if (statusIcon) {
          dateDiv.appendChild(statusIcon);
        }
        if (disabledIcon) {
          dateDiv.appendChild(disabledIcon);
        }
        const authorDiv = document.createElement('div');
        authorDiv.className = 'commit-actor';
        authorDiv.textContent = commit && commit.author ? 'by ' + commit.author : '';
        td.appendChild(dateDiv);
        if (commit && commit.author) {
          td.appendChild(authorDiv);
        }
        return td;
      }

      function createLastReleaseCell(release) {
        const td = document.createElement('td');
        td.className = 'commit-cell';
        const hasContent = release && (release.date || release.tag_name || release.url);
        const sortDate = release && release.date ? Date.parse(release.date) : null;
        td.dataset.order = normalizeSortValue(sortDate);
        if (!hasContent) {
          td.appendChild(emptyMarker());
          return td;
        }
        const dateClass = classifyEntryAge(release.date);
        const dateDiv = document.createElement('div');
        dateDiv.className = 'commit-date';
        if (dateClass) {
          dateDiv.classList.add(dateClass);
        }
        if (release.url) {
          const link = document.createElement('a');
          link.href = release.url;
          link.textContent = formatDateMonth(release.date) || 'release';
          const tooltipBits = [];
          if (release.date) tooltipBits.push('Date: ' + formatDateDay(release.date));
          if (release.tag_name) tooltipBits.push('Tag: ' + release.tag_name);
          link.title = tooltipBits.join(' â€¢ ');
          dateDiv.appendChild(link);
        } else {
          dateDiv.textContent = formatDateMonth(release.date) || 'release';
        }
        const tagDiv = document.createElement('div');
        tagDiv.className = 'commit-actor';
        tagDiv.textContent = release.tag_name || '';
        td.appendChild(dateDiv);
        td.appendChild(tagDiv);
        return td;
      }

      function createTopicsCell(topics) {
        const td = document.createElement('td');
        td.className = 'topics-cell';
        if (!topics || topics.length === 0) {
          td.appendChild(emptyMarker());
        } else {
          td.textContent = topics.join(', ');
        }
        return td;
      }

      function buildHeader() {
        const thead = document.createElement('thead');
        const row = document.createElement('tr');
        headers.forEach(header => {
          const th = document.createElement('th');
          const label = typeof header === 'string' ? header : header.text;
          th.textContent = label;
          if (header && typeof header === 'object' && header.title) {
            th.title = header.title;
          }
          row.appendChild(th);
        });
        thead.appendChild(row);
        return thead;
      }

      function buildRow(pkg) {
        const repoInfo = pkg.repo_info || {};
        const tr = document.createElement('tr');
        tr.appendChild(createOwnerCell(pkg));
        tr.appendChild(createNameCell(pkg));
        tr.appendChild(createTextCell(formatNumber(repoInfo.stargazers_count), 'meta-cell', Number(repoInfo.stargazers_count)));
        tr.appendChild(createTextCell(repoInfo.open_issues, 'meta-cell', Number(repoInfo.open_issues)));
        tr.appendChild(createTextCell(formatYear(repoInfo.created_at), 'meta-cell', Date.parse(repoInfo.created_at || '')));
        tr.appendChild(createLastCommitCell(pkg.last_commit, pkg.disabled_workflows, pkg.repo));
        tr.appendChild(createLastReleaseCell(pkg.last_release));
        tr.appendChild(createTopicsCell(repoInfo.topics));
        return tr;
      }

      function buildSection(section) {
        const card = document.createElement('div');
        card.className = 'section-card';
        const title = document.createElement('h2');
        title.textContent = section.name || 'Section';
        card.appendChild(title);

        const table = document.createElement('table');
        table.className = 'repo-table';
        table.appendChild(buildHeader());

        const tbody = document.createElement('tbody');
        (section.packages || []).forEach(pkg => {
          tbody.appendChild(buildRow(pkg));
        });
        table.appendChild(tbody);
        card.appendChild(table);
        return card;
      }

      function render(data) {
        clearError();
        sectionsEl.innerHTML = '';
        if (data.generated_at) {
          const d = new Date(data.generated_at);
          const formatted = Number.isNaN(d.getTime())
            ? data.generated_at
            : d.toISOString().slice(0, 16).replace('T', ' ');
          generatedAtEl.textContent = 'Generated at ' + formatted;
        } else {
          generatedAtEl.textContent = '';
        }
        (data.sections || []).forEach(section => {
          sectionsEl.appendChild(buildSection(section));
        });
        enhanceTables();
      }

      function enhanceTables() {
        if (!window.simpleDatatables || !simpleDatatables.DataTable) return;
        document.querySelectorAll('.repo-table').forEach(table => {
          if (table.dataset.enhanced === '1') return;
          new simpleDatatables.DataTable(table, {
            searchable: false,
            perPageSelect: false,
            perPage: 50,
            paging: false,
          });
          table.dataset.enhanced = '1';
        });
      }

      async function loadDashboard() {
        try {
          const parsed = await fetchYaml('generated.yml');
          if (!parsed || !parsed.sections) {
            throw new Error('generated.yml is missing required fields');
          }
          render(parsed);
        } catch (err) {
          sectionsEl.innerHTML = '';
          setError('Could not load dashboard data: ' + err.message);
        }
      }

      function classifyEntryAge(dateStr) {
        if (!dateStr) return '';
        const parsed = Date.parse(dateStr);
        if (Number.isNaN(parsed)) return '';
        const now = Date.now();
        const diffDays = (now - parsed) / (1000 * 60 * 60 * 24);
        if (diffDays <= 7) return 'commit-fresh';
        if (diffDays <= 30) return 'commit-recent';
        if (diffDays <= 365) return 'commit-stale';
        return 'commit-old';
      }

      loadDashboard();
    })();
  </script>
</body>

</html>
